# golang_calc

---

## Cодержание
- [О проекте](#о-проекте)
- [Схема и описание работы](#схема-и-описание-работы)
- [Приступая к работе](#приступая-к-работе)
    - [Инструкция по установке для Linux](#инструкция-по-установке-для-linux)
    - [Инструкция по установке для Windows](#инструкция-по-установке-для-windows)
    - [Восстановление базы данных из образа](#восстановление-базы-данных-из-образа)
- [Запуск](#запуск)
- [Использование](#использование)
    - [Позитивные исходы](#позитивные-исходы)
        - [Сценарий 1](#сценарий-1)
        - [Cценарий 2](#сценарий-2)
    - [Негативные исходы](#негативные-исходы)
        - [Сценарий 1](#сценарий-1-1)
        - [Сценарий 2](#сценарий-2-1)

---

## О проекте
Это сервис, принимающий арифметические выражения и посылающий их на микросервис (агент). Он состоит из оркестратора, агента и базы данных.

---

## Схема и описание работы
Данный проект работает следующим образом:
1. Принимает выражение от пользователя.
2. Парсит его на подвыражения в базу данных и возвращает `id` главного подвыражения, зависящего от всех остальных.
3. Получает из БД "разрешенные" подвыражения (независимые от других).
4. Если их нет, то перейти к пункту 9.
5. Отправляет их агенту.
6. Получая результат, записывает его в `/api/v1/expressions`.
7. Меняет статус "независимости" в БД.
8. Переход к пункту 3.
9. Записывает результат и отсылает всё в `api/v1/expressions`, а пользователю - `id`.


![Архитектура](https://github.com/dinklen/golang_calc/architecture.tiff)
---

## Приступая к работе
Так как проект работает с базой данных (на PostgreSQL), то необходимо установить недостающие пакеты.

### Инструкция по установке для *Linux*
1. Установка PostgreSQL (это ещё не всё). Введите в терминале следующее:
```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
```

2. После того, как установка завершится, необходимо эту службу запустить:
```bash
sudo systemctl start postgresql
sudo systemctl enable postgresql
```

### Инструкция по установке для *Windows*
1. Установка установщика с [офийиального сайта](https://www.postgresql.org/download/windows/).
2. Запустите установщик и следуйте инструкциям, которые он выводит.
3. Для управления базой данных можно использовать [pgAdmin](https://www.pgadmin.org/).

### Восстановление базы данных из образа
Дело осталось за малым. Нужно восстановить БД из образа. Для этого в **Windows** создаём базу данных с именем `subexpressions` в *pgAdmin*, а в **Linux** нужно ввести следующие команды:
```bash
# нужно вводить эту команду, находясь в каталоге database этого проекта
psql -U postgres
```

Открывается *PostgreSQL*.
```sql
CREATE DATABASE subexpressions;
\q
```

Снова терминал.
```bash
pg_restore -U postgres -d subexpressions -v "subexpressions.dump"
```

> При возникновении проблем с установкой или дополнительных вопросов - пишите в ишью.

## Запуск
Приступим к самому запуску проекта.

1. Для начала необходимо клонировать этот репозиторий к себе в директорию:
```bash
git clone https://github.com/dinklen/golang_calc.git

cd golang_calc
```

2. Следующим этапом идёт объявление переменных окружения (не обязательно, по умолчанию задержка у всех будет равна `100` ms, порт у оркестратора и агента - `8080` и `8081` соответственно, а максимальное кол-во горутин - `5`).

На **Linux**:
```bash
export APP_PORT="8080"
export AGENT_PORT="8081"
export TIME_ADDITION_MS="100"
export TIME_SUBTRACTION_MS="100"
export TIME_MULTIPLICATIONS_MS="100"
export TIME_DIVISIONS_MS="100"
export COMPUTING_POWER="5"
```

На **Windows**:
Те же команды, если использовать WSL.

> Если эти переменные изменять, то вводить их значения нужно в двух терминалах (где будет запущен агент и оркестратор).

| **Название** | **Описание** | **Значение по умолчанию** |
| :---: | :---: | :---: |
| `APP_PORT` | Порт, на котором запускается основной сервер (оркестратор) | `8080` |
| `AGENT_PORT` | Порт, на котором запускается микросервис, на котором происходят вычисления подвыражений (агент) | `8081` |
| `TIME_ADDITION_MS` | Задержка операции сложения в миллисекундах | `100` |
| `TIME_SUBTRACTION_MS` | Зажержка операции вычитания в миллисекундах | `100` |
| `TIME_MULTIPLICATIONS_MS` | Зажержка операции умножения в миллисекундах | `100` |
| `TIME_DIVISIONS_MS` | Зажержка операции деления в миллисекундах | `100` |
| `COMPUTING_POWER` | Максимальное количество горутин, которых агент может использовать одновременно | `5` |

> В примере приведены значения по умолчанию. Менять или прописывать их необязательно.


3. Затем можно производить запуск (первоначально нужно запустить оркестратор, затем уже агент (как микросервис)).

На ***Linux***:
```bash
# запуск оркестратора в первом терминале
go run cmd/orchestrator/main.go

# запуск агента во втором терминале
go run cmd/agent/main.go
```

На ***Windows***:

Те же команды, только необходимо заменить слэши на обратные.

---

## Использование
В зависимости от запроса будут определённые статус-коды и сообщения.

**Статус-код** | **Сообщение** | **Описание**
:---: | :---: | :---:
`404` | `Page not found` | Введён некорректный адрес отправки запроса
`405` | `Access denied` | Использован некорректный метод
`422` | `Invalid input` | Отправлено некорректное выражение
`500` | `Internal server error` | Внутренняя ошибка сервера
`201` | - | Данные успешно получены
`200` | - | Результат выполнения задачи - ОК

### Позитивные исходы
Для взаимодействия с калькулятором необходимо открыть третий терминал. Далее, для отправки выражения ввести команду:
```bash
curl --location 'localhost:<порт, на котором запущен оркестратор>/api/v1/calculate' \
--header 'Content-Type: application/json' \
--data '{"expression":"<ваше выражение>"}'
```

> Далее, на замену "<порт, на котором запущен оркестратор>" придёт обычное "<PORT>".

Результат будет в формате **JSON**:
```json
{
    "id":<id выражения>
}
```

Это - `id` выражения. Для получения результата необходимо сделать ещё один запрос:
```bash
curl --location 'localhost:<PORT>/api/v1/expressions/<id>'
```

Результат также будет в формате **JSON**:
```json
{
    "id":<id>
    "status":<"waiting"/"calculating"/"calculated">
    "result":<результат вычислений>
}
```

Но при этом можно получить список всех подвыражений:
```bash
curl --location 'localhost:<PORT>/api/v1/expressions'
```

Тогда ответ будет таким:
```json
{
    "expressions":[
        {
            "id":<id>
            "status":<"waiting"/"calculating"/"calculated">
            "result":<результат вычислений/0>
        },
        {
            "id":<id>
            "status":<"waiting"/"calculating"/"calculated">
            "result":<результат вычислений/0>
        }
    ]
}
```

#### Сценарий 1:
Всё установив и запустив, я ввожу:
1.  ```bash
    curl --location 'localhost:8080/api/v1/calculate' \
    --header 'Content-Type: application/json' \
    --data '{"expression":"1+1"}'
    ```

    ...немного подождав, появляется вывод...
    ```json
    {"id":2799747341}
    ```

    Мне интересно, что-же получилось в итоге, поэтому ввожу следующее:

2.  ```bash
    curl --location 'localhost:8080/api/v1/expressions/2799747341'
    ```

    ...и появляется вывод...
    
    ```json
    {"id":2799747341,"status":"calculated","result":2}
    ```

    Ого! Будет 2! Но что там с остальными задачами?

3.  ```bash
    curl --location 'localhost:8080/api/v1/expressions
    ```

    ...как итог...

    ```json
    {"expressions":[{"id":2799747341,"status":"calculated","result":2}]}
    ```

    Задача всего одна, т.к. выражение состоит всего из двух чисел (а это самый минимум для вычисления агентом). Надо бы это исправить!

#### Сценарий 2:
Сейчас можно посмотреть на паралельные вычисления:
1.  ```bash
    curl --location 'localhost:8080/api/v1/calculate' \
    --header 'Content-Type: application/json' \
    --data '{"expression":"2*9+4*3"}'
    ```

    ...ждём...

    ```json
    {"id":3052512492}
    ```

    Запросим итоговый результат.
2.  ```bash
    curl --location 'localhost:8080/api/v1/expressions/3052512492'
    ```

    ...вывод...

    ```json
    {"id":3052512492,"status":"calculated","result":30}
    ```

    Результат 30. Но мы хотели посмотреть выполненные подзадачи.

3.  ```bash
    curl --location 'localhost:8080/api/v1/expressions'
    ```

    На этот раз исход другой

    ```json
    {
        "expressions":[
            {
                "id":2782069059,
                "status":"calculated",
                "result":12
            },
            {
                "id":1097090243,
                "status":"calculated",
                "result":18
            },
            {
                "id":3052512492,
                "status":"calculated",
                "result":30
            }
        ]
    }
    ```
    Операторы `*` и `/` берут вверх, и в этом случае друг от друга они не зависели. Поэтому 2 вычисления получилось произвести параллельно.

### Негативные исходы
1. Введя некорректное выражение, а затем запросив его результат (после подсчётов), мы получим следующее:
```json
{
    "id":<id>
    "status":"error"
    "result":0
}
```

В логах можно будет увидеть причину (логируется всё в терминал). Код ответа, в таком случае, - `422`.

2. При вводе некорректного адреса для отправки метода сразу же получим вывод с статус кодом `404`: `page not found`

3. Попытавшись использовать неразрешённый метод, получим результат с кодом `405`:`Access denied`

4. Если что-то пойдёт не так во время обработки вычислений/отправки сообщений/..., то мы получим результат с кодом `500`:`Internal server error`

Все будет получено в формате **JSON**.

#### Сценарий 1:
Теперь можно приступить к его поломке.
1.  ```bash
    curl --location 'localhost:8080/api/v1/calculate' \
    --header 'Content-Type: application/json' \
    --data '{"expression":"12/0"}'
    ```

    ...и спустя время...
    ```json
    {"id":0}
    ```

    Теперь запросим ответ.

2.  ```bash
    curl --location 'localhost:8080/api/v1/expressions
    ```

    ...ответ...
    ```json
    {
        "expressions": [
            {
                "id":0,
                "status":"error",
                "result":1.7976931348623157e+308
            }
        ]
    }
    ```

> Максимальное значение для float64 выставлено специально - как показатель ошибки.

#### Сценарий 2:
Проверим на ввод некорректных символов:
```bash
url --location 'localhost:8080/api/v1/calculate' \
--header 'Content-Type: application/json' \
--data '{"expression":"2x+8"}'
```

После нажатия на "Enter" сразу выходит ошибка:
```json
{"error":"Expression is not valid: incorrect input"}
```

---

## ps
я уже понял, что всё надо переписывать хотя бы с 0
